"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[6340],{5172:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>l,contentTitle:()=>a,default:()=>h,frontMatter:()=>r,metadata:()=>o,toc:()=>d});var t=i(4848),s=i(8453);const r={slug:"matrices-github-actions",title:"An Ultimate Guide to Matrices in GitHub Actions, from Basic to Advanced",authors:"manu",tags:["github actions","ci/cd","devops"]},a=void 0,o={permalink:"/blog/tech/matrices-github-actions",source:"@site/tech/2025-03-28-matrices-github-actions/index.md",title:"An Ultimate Guide to Matrices in GitHub Actions, from Basic to Advanced",description:"Listen, I feel the boldest of girls for calling this *an* ultimate guide. But it's just because this will be the one post about matrices I'll update over time as I experience more. All info in a single place for easier retrieval, enjoy!",date:"2025-03-28T00:00:00.000Z",tags:[{label:"github actions",permalink:"/blog/tech/tags/github-actions"},{label:"ci/cd",permalink:"/blog/tech/tags/ci-cd"},{label:"devops",permalink:"/blog/tech/tags/devops"}],readingTime:17.47,hasTruncateMarker:!0,authors:[{name:"Manu Magalh\xe3es",title:"DevSecOps Engineer",url:"https://github.com/magmanu",imageURL:"https://github.com/magmanu.png",key:"manu"}],frontMatter:{slug:"matrices-github-actions",title:"An Ultimate Guide to Matrices in GitHub Actions, from Basic to Advanced",authors:"manu",tags:["github actions","ci/cd","devops"]},unlisted:!1,nextItem:{title:"GitHub Actions: Data Flow & Data Persistence",permalink:"/blog/tech/github-actions-data-flow"}},l={authorsImageUrls:[void 0]},d=[{value:"Basics: Simple Matrix",id:"basics-simple-matrix",level:2},{value:"Multidimensional Matrices (Matrix with Multiple Keys)",id:"multidimensional-matrices-matrix-with-multiple-keys",level:2},{value:"Adjusting matrices with <code>include</code> &amp; <code>exclude</code>, part I: the &quot;odd job&quot;",id:"adjusting-matrices-with-include--exclude-part-i-the-odd-job",level:2},{value:"Static usage",id:"static-usage",level:3},{value:"<code>include</code>",id:"include",level:4},{value:"<code>exclude</code>",id:"exclude",level:4},{value:"The Declarative Case: <code>include</code> as a flattenning tool",id:"the-declarative-case-include-as-a-flattenning-tool",level:3},{value:"Dynamic exclusions",id:"dynamic-exclusions",level:3},{value:"Adjusting matrices with <code>include</code> &amp; <code>exclude</code>, part II: the small print",id:"adjusting-matrices-with-include--exclude-part-ii-the-small-print",level:2},{value:"What <code>include</code> doesn&#39;t do",id:"what-include-doesnt-do",level:3},{value:"<code>include</code> doesn&#39;t inherit the matrix key/value pairs",id:"include-doesnt-inherit-the-matrix-keyvalue-pairs",level:4},{value:"Array values for <code>include</code> do not spread into separate jobs",id:"array-values-for-include-do-not-spread-into-separate-jobs",level:4},{value:"Advice for using<code>include</code>",id:"advice-for-usinginclude",level:3},{value:"Be explicit about all desired key/value pairs to the matrix",id:"be-explicit-about-all-desired-keyvalue-pairs-to-the-matrix",level:4},{value:"Each <code>include</code> map is an independent unit",id:"each-include-map-is-an-independent-unit",level:4},{value:"Feel free to add brand new keys not present in the base matrix",id:"feel-free-to-add-brand-new-keys-not-present-in-the-base-matrix",level:4},{value:"Case Study: More Complex Matrices",id:"case-study-more-complex-matrices",level:2},{value:"The declarative approach",id:"the-declarative-approach",level:3},{value:"The <code>include</code>/<code>exclude</code> approach",id:"the-includeexclude-approach",level:3},{value:"Simplifying &quot;particular combinations&quot; in matrices",id:"simplifying-particular-combinations-in-matrices",level:2},{value:"Handling glitches in the matrix",id:"handling-glitches-in-the-matrix",level:2},{value:"Matrix job failures",id:"matrix-job-failures",level:3},{value:"<code>fail-fast</code>",id:"fail-fast",level:4},{value:"<code>continue-on-error</code>",id:"continue-on-error",level:4},{value:"<code>matrix.experimental</code>",id:"matrixexperimental",level:4},{value:"Dynamically-generated matrices: Handling Empty Matrix Error",id:"dynamically-generated-matrices-handling-empty-matrix-error",level:3}];function c(e){const n={a:"a",br:"br",code:"code",em:"em",h2:"h2",h3:"h3",h4:"h4",img:"img",li:"li",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,s.R)(),...e.components},{Details:r}=n;return r||function(e,n){throw new Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("Details",!0),(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.p,{children:(0,t.jsxs)(n.em,{children:["Listen, I feel the boldest of girls for calling this ",(0,t.jsx)(n.em,{children:"an"})," ultimate guide. But it's just because this will be the one post about matrices I'll update over time as I experience more. All info in a single place for easier retrieval, enjoy!"]})}),"\n",(0,t.jsx)(n.p,{children:"Matrices keep workflows DRY: you setup a job once and let the matrix do the boring work of multiplying it with all the different configurations required."}),"\n",(0,t.jsx)(n.h2,{id:"basics-simple-matrix",children:"Basics: Simple Matrix"}),"\n",(0,t.jsx)(n.p,{children:"Use a matrix to run the same job multiple times, with different configurations."}),"\n",(0,t.jsxs)(n.p,{children:["Matrices are set at the job level, under the ",(0,t.jsx)(n.code,{children:"strategy"})," key. Then, at the step level, reference the matrix values with ",(0,t.jsx)(n.code,{children:"${{ matrix.key_name}}"}),"."]}),"\n",(0,t.jsx)(n.p,{children:"Let's follow the classic workflow example, of course: running CI tests in different versions of Node.js."}),"\n",(0,t.jsxs)(r,{children:[(0,t.jsx)("summary",{children:(0,t.jsx)(n.p,{children:"Show code"})}),(0,t.jsx)("div",{children:(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-yaml",metastring:'title=".github/workflows/testing.yaml" showLineNumbers',children:"(...)\njobs:\n  unit-tests:\n    // highlight-start\n    strategy:\n      matrix:\n        # I named it `node-version`, but you can name it however you want\n        node-version: [16, 18] \n    // highlight-end\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout\n        (...)\n\n      // highlight-start\n      # And to reference it, use `${{ matrix.key_name}}`\n      - name: Use Node.js ${{ matrix.node-version }}\n      // highlight-end\n        uses: actions/setup-node@v4\n        with:\n        // highlight-next-line\n          node-version: ${{ matrix.node-version }}\n\n      (...)\n"})})})]}),"\n",(0,t.jsxs)(r,{children:[(0,t.jsx)("summary",{children:(0,t.jsx)(n.p,{children:"Show pipeline"})}),(0,t.jsx)("div",{children:(0,t.jsx)(n.p,{children:(0,t.jsx)(n.img,{alt:"screenshot",src:i(6557).A+"",width:"624",height:"436"})})})]}),"\n",(0,t.jsx)(n.h2,{id:"multidimensional-matrices-matrix-with-multiple-keys",children:"Multidimensional Matrices (Matrix with Multiple Keys)"}),"\n",(0,t.jsxs)(n.p,{children:["Of course this can get more complex. If you want to run your tests in Node.js 16 & 18, ",(0,t.jsx)(n.strong,{children:"and"})," test each node version in a different OS, you can use a matrix with multiple keys (aka matrix of matrices, or multidimensional matrices)."]}),"\n",(0,t.jsx)(n.p,{children:"Please note: in a matrix of matrices, the number of jobs is the product of the matrix sizes - that is, the number of items in matrix A multiplied by the number of items in matrix B."}),"\n",(0,t.jsx)(n.p,{children:"So if we specify two node versions and two OSs, like this..."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-yaml",metastring:'title=".github/workflows/testing.yaml" showLineNumbers',children:"matrix:\n  os: [ubuntu-latest, windows-latest]\n  node-version: [16, 18]\n"})}),"\n",(0,t.jsx)(n.p,{children:"... we'll end up with 4 jobs (2*2):"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"ubuntu-latest + node 16"}),"\n",(0,t.jsx)(n.li,{children:"ubuntu-latest + node 18"}),"\n",(0,t.jsx)(n.li,{children:"windows-latest + node 16"}),"\n",(0,t.jsx)(n.li,{children:"windows-latest + node 18"}),"\n"]}),"\n",(0,t.jsxs)(r,{children:[(0,t.jsx)("summary",{children:(0,t.jsx)(n.p,{children:"Show code"})}),(0,t.jsx)("div",{children:(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-yaml",metastring:'title=".github/workflows/testing.yaml" showLineNumbers',children:"(...)\n  unit-tests:\n    strategy:\n      matrix:\n      // highlight-start\n        os: [ubuntu-latest, windows-latest]\n        node-version: [16, 18]\n    runs-on: ${{ matrix.os }}\n    // highlight-end\n    steps:\n      - name: Checkout\n        (...)\n\n      // highlight-next-line\n      - name: Use Node.js ${{ matrix.node-version }} in ${{ matrix.os }}\n        uses: actions/setup-node@v2\n        with:\n          node-version: ${{ matrix.node-version }}\n\n      (...)\n"})})})]}),"\n",(0,t.jsxs)(r,{children:[(0,t.jsx)("summary",{children:(0,t.jsx)(n.p,{children:"Show pipeline"})}),(0,t.jsx)("div",{children:(0,t.jsx)(n.p,{children:(0,t.jsx)(n.img,{alt:"screenshot",src:i(1698).A+"",width:"628",height:"616"})})})]}),"\n",(0,t.jsxs)(n.p,{children:["You can have as many keys you want, but keep in mind that the number of jobs ",(0,t.jsx)(n.strong,{children:"can grow exponentially"}),". For example, if you have 4 matrices keys with 3 values each, you'll end up with 81 jobs (3*3*3*3)."]}),"\n",(0,t.jsxs)(n.h2,{id:"adjusting-matrices-with-include--exclude-part-i-the-odd-job",children:["Adjusting matrices with ",(0,t.jsx)(n.code,{children:"include"})," & ",(0,t.jsx)(n.code,{children:"exclude"}),', part I: the "odd job"']}),"\n",(0,t.jsx)(n.h3,{id:"static-usage",children:"Static usage"}),"\n",(0,t.jsx)(n.p,{children:"If you know beforehand all the matrix values you'll use, you can set them statically."}),"\n",(0,t.jsx)(n.p,{children:"Let's say your team will also run tests for Node.js 18 in Windows machines. There are two ways to handle this:"}),"\n",(0,t.jsx)(n.h4,{id:"include",children:(0,t.jsx)(n.code,{children:"include"})}),"\n",(0,t.jsxs)(n.p,{children:["With ",(0,t.jsx)(n.code,{children:"include"}),", you can ",(0,t.jsx)(n.strong,{children:"add"}),' an "odd value" to your matrix.',(0,t.jsx)(n.br,{}),"\n","Below, we'll write a matrix for combinations between the Ubuntu OS and two Node.js versions, and use ",(0,t.jsx)(n.code,{children:"include"})," to add the odd ",(0,t.jsx)(n.code,{children:"windows-latest"})," + Node.js ",(0,t.jsx)(n.code,{children:"18"})," combination."]}),"\n",(0,t.jsxs)(r,{children:[(0,t.jsx)("summary",{children:(0,t.jsx)(n.p,{children:"Show code"})}),(0,t.jsx)("div",{children:(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-yaml",metastring:'title=".github/workflows/testing.yaml" showLineNumbers',children:"(...)\n  unit-tests:\n    strategy:\n      matrix:\n        os: [ubuntu-latest]\n        node-version: [16, 18]\n      // highlight-start\n      include: # add the odd combination\n        - os: windows-latest\n          node-version: 18\n      // highlight-end\n    runs-on: ${{ matrix.os }}\n        (...)\n"})})})]}),"\n",(0,t.jsx)(n.h4,{id:"exclude",children:(0,t.jsx)(n.code,{children:"exclude"})}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"exclude"})," works in the opposite direction: you add all values to the matrix and use ",(0,t.jsx)(n.code,{children:"exclude"})," to ",(0,t.jsx)(n.strong,{children:"remove"})," the undesirable matches."]}),"\n",(0,t.jsxs)(r,{children:[(0,t.jsx)("summary",{children:(0,t.jsx)(n.p,{children:"Show code"})}),(0,t.jsx)("div",{children:(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-yaml",metastring:'title=".github/workflows/testing.yaml" showLineNumbers',children:"(...)\n  unit-tests:\n    strategy:\n      matrix:\n        os: [ubuntu-latest, windows-latest]\n        node-version: [16, 18]\n      // highlight-start\n      exclude: # remove unwanted combination\n        - os: windows-latest\n          node-version: 16\n      // highlight-end\n    runs-on: ${{ matrix.os }}\n        (...)\n"})})})]}),"\n",(0,t.jsxs)(r,{children:[(0,t.jsx)("summary",{children:(0,t.jsx)(n.p,{children:"Show pipeline: the pipeline looks the same in both cases"})}),(0,t.jsxs)("div",{children:[(0,t.jsx)(n.p,{children:"Now there are only 3 jobs - also, the job completion for windows went down from 1m23/1m35s to 44s thanks to caching :)"}),(0,t.jsx)(n.p,{children:(0,t.jsx)(n.img,{alt:"screenshot",src:i(6523).A+"",width:"552",height:"466"})})]})]}),"\n",(0,t.jsxs)(n.h3,{id:"the-declarative-case-include-as-a-flattenning-tool",children:["The Declarative Case: ",(0,t.jsx)(n.code,{children:"include"})," as a flattenning tool"]}),"\n",(0,t.jsxs)(n.p,{children:["If you prefer clarity over brevity, you can use ",(0,t.jsx)(n.code,{children:"include"})," to flatten matrices. Just beware that this can make your workflow harder to maintain."]}),"\n",(0,t.jsxs)(r,{children:[(0,t.jsx)("summary",{children:(0,t.jsx)(n.p,{children:"Show code"})}),(0,t.jsx)("div",{children:(0,t.jsx)(n.p,{children:(0,t.jsx)(n.img,{alt:"screenshot",src:i(3356).A+"",width:"1642",height:"486"})})})]}),"\n",(0,t.jsx)(n.h3,{id:"dynamic-exclusions",children:"Dynamic exclusions"}),"\n",(0,t.jsxs)(n.p,{children:["This is my favourite. You can use ",(0,t.jsx)(n.code,{children:"exclude"})," to dynamically adjust matrix values."]}),"\n",(0,t.jsxs)(n.p,{children:["Let's suppose your team decides that every Tuesday you will run tests in the most recent Node.js version, as a peek into changes you'll have to make in the future. You can use ",(0,t.jsx)(n.code,{children:"include"})," to run the new version to the matrix ",(0,t.jsx)(n.em,{children:"only on Tuesdays"}),"."]}),"\n",(0,t.jsxs)(r,{children:[(0,t.jsx)("summary",{children:(0,t.jsx)(n.p,{children:"Show code"})}),(0,t.jsx)("div",{children:(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-yaml",metastring:'title=".github/workflows/testing.yaml" showLineNumbers',children:'  jobs:\n    get_weekday:\n      runs-on: ubuntu-latest\n      outputs:\n        WEEKDAY: ${{ steps.get_weekday.outputs.WEEKDAY }}\n      steps:\n        - name: Get day of the week\n          id: get_weekday\n          run: echo "WEEKDAY=$(date \'+%a\')" | tee -a "$GITHUB_OUTPUT"\n\n    unit-tests:\n      runs-on: ubuntu-latest\n      needs: get_weekday\n      strategy:\n        matrix:\n          node-version: [16, 18, 24]\n          // highlight-start\n          exclude:\n            - node-version: ${{ needs.get_weekday.outputs.WEEKDAY != \'Tue\' && 24 || \'\' }}\n          // highlight-end\n      steps:\n        - name: Run unit tests\n          run: |\n            echo "Today is ${{ needs.get_weekday.outputs.WEEKDAY }}."\n            echo "Let\'s run tests for Node.js v${{ matrix.node-version }}"\n      (...)\n'})})})]}),"\n",(0,t.jsxs)(r,{children:[(0,t.jsx)("summary",{children:(0,t.jsx)(n.p,{children:"Show pipeline"})}),(0,t.jsx)("div",{children:(0,t.jsx)(n.p,{children:(0,t.jsx)(n.img,{alt:"screenshot",src:i(3415).A+"",width:"1498",height:"726"})})})]}),"\n",(0,t.jsxs)(n.p,{children:["You may have noticed this funny syntax: ",(0,t.jsx)(n.code,{children:"${{ needs.get_weekday.outputs.WEEKDAY != 'Tue' && 24 || '' }}"}),". This is a way to ",(0,t.jsx)(n.a,{href:"https://docs.github.com/en/actions/learn-github-actions/expressions#:~:text=ternary,expressions",children:"use ternaries in Github Actions"}),". If the weekday ",(0,t.jsx)(n.em,{children:"is not"})," Tuesday, this expression will return ",(0,t.jsx)(n.code,{children:"24"}),", meaning that ",(0,t.jsx)(n.code,{children:"24"})," will be excluded from the ",(0,t.jsx)(n.code,{children:"node-version"})," array values. But, on Tuesdays, this expression will return an empty value => ",(0,t.jsx)(n.code,{children:"24"})," will not be excluded =>  all node-versions set in the base matrix run => Node.js 24 will run."]}),"\n",(0,t.jsxs)(n.p,{children:["Now, why ",(0,t.jsx)(n.code,{children:"exclude"})," instead of ",(0,t.jsx)(n.code,{children:"include"}),"?",(0,t.jsx)(n.br,{}),"\n","Honestly, I haven't found a decent way to get ",(0,t.jsx)(n.code,{children:"included"})," to work with this use case. With ",(0,t.jsx)(n.code,{children:"include"}),", the syntax would be dreadful:  We have to use a ternary both for key and value. You sure you want... this thing below? I sure don't."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-yaml",children:"include:\n  - { \"${{needs.get_weekday.outputs.WEEKDAY != 'Tue' && 'node-version' || ''}}\": \"${{needs.get_weekday.outputs.WEEKDAY != 'Tue' && 24 || ''}}\" }\n"})}),"\n",(0,t.jsxs)(n.h2,{id:"adjusting-matrices-with-include--exclude-part-ii-the-small-print",children:["Adjusting matrices with ",(0,t.jsx)(n.code,{children:"include"})," & ",(0,t.jsx)(n.code,{children:"exclude"}),", part II: the small print"]}),"\n",(0,t.jsxs)(n.h3,{id:"what-include-doesnt-do",children:["What ",(0,t.jsx)(n.code,{children:"include"})," doesn't do"]}),"\n",(0,t.jsxs)(n.p,{children:["First, let's see what you ",(0,t.jsx)(n.strong,{children:"cannot/should not"})," do with ",(0,t.jsx)(n.code,{children:"include"}),":"]}),"\n",(0,t.jsxs)(n.h4,{id:"include-doesnt-inherit-the-matrix-keyvalue-pairs",children:[(0,t.jsx)(n.code,{children:"include"})," doesn't inherit the matrix key/value pairs"]}),"\n",(0,t.jsxs)(n.p,{children:["Just because a key/value pair is present in the matrix, it doesn't mean ",(0,t.jsx)(n.code,{children:"include"})," inherits it."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-yaml",children:'    strategy:\n        matrix:\n          os: [windows-latest, ubuntu-latest]\n          node-version: [18]\n          region: [Asia, Latam]\n          // highlight-start\n          include:\n            - os: macos-latest\n          // highlight-end\n    steps:\n      - name: ${{ matrix.os }} ${{ matrix.node-version }} ${{ matrix.region }}\n        run: |\n          echo "OS: ${{ matrix.os }}"\n          echo "Node Version: ${{ matrix.node-version }}"\n          echo "Region: ${{ matrix.region }}"\n'})}),"\n",(0,t.jsxs)(n.p,{children:["In this example, because you haven't defined a ",(0,t.jsx)(n.code,{children:"node-version"})," or ",(0,t.jsx)(n.code,{children:"region"})," in your include map, those values will be empty in the included job."]}),"\n",(0,t.jsxs)(r,{children:[(0,t.jsx)("summary",{children:(0,t.jsx)(n.p,{children:"Show pipeline"})}),(0,t.jsx)("div",{children:(0,t.jsx)(n.p,{children:(0,t.jsx)(n.img,{alt:"screenshot",src:i(4544).A+"",width:"2180",height:"576"})})})]}),"\n",(0,t.jsxs)(n.h4,{id:"array-values-for-include-do-not-spread-into-separate-jobs",children:["Array values for ",(0,t.jsx)(n.code,{children:"include"})," do not spread into separate jobs"]}),"\n",(0,t.jsxs)(n.p,{children:["In this example, the ",(0,t.jsx)(n.code,{children:"region"})," array  ",(0,t.jsx)(n.strong,{children:"will not"})," spin a ",(0,t.jsx)(n.code,{children:"macos-latest"})," job for each region. The ",(0,t.jsx)(n.code,{children:"include"})," will spin a ",(0,t.jsx)(n.strong,{children:"single"})," MacOS job that takes the whole array as the value for ",(0,t.jsx)(n.code,{children:"region"}),", as you can see in the screenshot below. You can, however, extract the values from the array using the bracket notation ",(0,t.jsx)(n.code,{children:"matrix.region[0]"}),"."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-yaml",children:'    strategy:\n        matrix:\n          os: [windows-latest, ubuntu-latest]\n          node-version: [18]\n          region: [Asia, Latam]\n          include:\n            - os: macos-latest\n            // highlight-next-line\n              region: [Asia, Latam]\n    steps:\n      - name: ${{ matrix.os }} ${{ matrix.region }}\n        run: |\n          echo "OS: ${{ matrix.os }}"\n          echo "Node Version: ${{ matrix.node-version }}"\n          echo "First Region: ${{ matrix.region[0] }}"\n          echo "Second Region: ${{ matrix.region[1] }}"\n'})}),"\n",(0,t.jsxs)(r,{children:[(0,t.jsx)("summary",{children:(0,t.jsx)(n.p,{children:"Show pipeline"})}),(0,t.jsx)("div",{children:(0,t.jsx)(n.p,{children:(0,t.jsx)(n.img,{alt:"screenshot",src:i(2665).A+"",width:"2184",height:"626"})})})]}),"\n",(0,t.jsxs)(n.h3,{id:"advice-for-usinginclude",children:["Advice for using",(0,t.jsx)(n.code,{children:"include"})]}),"\n",(0,t.jsxs)(n.p,{children:["Now, what you ",(0,t.jsx)(n.strong,{children:"can/must"})," do with ",(0,t.jsx)(n.code,{children:"include"}),", some of which you might have guessed already from the previous points."]}),"\n",(0,t.jsx)(n.h4,{id:"be-explicit-about-all-desired-keyvalue-pairs-to-the-matrix",children:"Be explicit about all desired key/value pairs to the matrix"}),"\n",(0,t.jsxs)(n.p,{children:["If you want a key/value pair in ",(0,t.jsx)(n.code,{children:"include"}),", well... include it. It won't magically appear by inheritance."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-yaml",children:'    strategy:\n        matrix:\n          os: [windows-latest, ubuntu-latest]\n          node-version: [18]\n          region: [Asia, Latam]\n          // highlight-start\n          include:\n            - os: macos-latest\n              node-version: 20\n              region: Asia\n          // highlight-end\n    steps:\n      - name: ${{ matrix.os }} ${{ matrix.node-version }} ${{ matrix.region }}\n        run: |\n          echo "OS: ${{ matrix.os }}"\n          echo "Node Version: ${{ matrix.node-version }}"\n          echo "Region: ${{ matrix.region }}"\n'})}),"\n",(0,t.jsxs)(n.h4,{id:"each-include-map-is-an-independent-unit",children:["Each ",(0,t.jsx)(n.code,{children:"include"})," map is an independent unit"]}),"\n",(0,t.jsxs)(n.p,{children:["In the previous example, the ",(0,t.jsx)(n.code,{children:"macos-latest"})," job was only added to the ",(0,t.jsx)(n.code,{children:"Asia"})," region.\nIf you want  ",(0,t.jsx)(n.code,{children:"macos-latest"})," for ",(0,t.jsx)(n.code,{children:"Asia"})," and ",(0,t.jsx)(n.code,{children:"Latam"}),", you need to add an ",(0,t.jsx)(n.code,{children:"include"})," map for each of them. Do not try to combine them in a single map, that's not how ",(0,t.jsx)(n.code,{children:"include"})," works."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-yaml",children:'    strategy:\n        matrix:\n          os: [windows-latest, ubuntu-latest]\n          node-version: [18]\n          region: [Asia, Latam]\n          // highlight-start\n          include:\n            - os: macos-latest\n              node-version: 20\n              region: Asia\n            - os: macos-latest\n              node-version: 20\n              region: Latam\n          // highlight-end\n    steps:\n      - name: ${{ matrix.os }} ${{ matrix.node-version }} ${{ matrix.region }}\n        run: |\n          echo "OS: ${{ matrix.os }}"\n          echo "Node Version: ${{ matrix.node-version }}"\n          echo "Region: ${{ matrix.region }}"\n'})}),"\n",(0,t.jsx)(n.h4,{id:"feel-free-to-add-brand-new-keys-not-present-in-the-base-matrix",children:"Feel free to add brand new keys not present in the base matrix"}),"\n",(0,t.jsxs)(n.p,{children:['You\'re not restricted to modifying keys that already exist in the base matrix. You can add new ones too. Just keep in mind that "new" keys will be added to *',(0,t.jsx)(n.em,{children:"all"})," jobs in the matrix."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-yaml",children:'    strategy:\n        matrix:\n          os: [windows-latest, ubuntu-latest]\n          node-version: [18]\n          region: [Asia, Latam]\n          // highlight-start\n          include:\n            - report: true\n          // highlight-end\n    steps:\n      - name: ${{ matrix.os }} ${{ matrix.node-version }} ${{ matrix.region }} ${{ matrix.report }}\n        run: |\n          echo "OS: ${{ matrix.os }}"\n          echo "Node Version: ${{ matrix.node-version }}"\n          echo "Region: ${{ matrix.region }}"\n          echo "Should report: ${{ matrix.report }}"\n'})}),"\n",(0,t.jsxs)(r,{children:[(0,t.jsx)("summary",{children:(0,t.jsx)(n.p,{children:"Show pipeline"})}),(0,t.jsxs)("div",{children:[(0,t.jsx)(n.p,{children:"Repating, just to highlight it:"}),(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["When the keys of an ",(0,t.jsx)(n.code,{children:"include"})," map don't match any keys in the base matrix (as in the example above), ",(0,t.jsx)(n.strong,{children:"that new key will be added to every job in the matrix"}),"."]}),"\n"]}),(0,t.jsx)(n.p,{children:(0,t.jsx)(n.img,{alt:"screenshot",src:i(6798).A+"",width:"1379",height:"730"})})]})]}),"\n",(0,t.jsx)(n.h2,{id:"case-study-more-complex-matrices",children:"Case Study: More Complex Matrices"}),"\n",(0,t.jsxs)(n.p,{children:["When real life complexity knocks at your door, ",(0,t.jsx)(n.code,{children:"include"})," and ",(0,t.jsx)(n.code,{children:"exclude"})," can become confusing. I'll walk you through an implementation example to help you reason through your options."]}),"\n",(0,t.jsx)(n.p,{children:"Let's take the following scenario: you need to run tests for your product, but different regions have different requirements for the test suite. But they have one thing in common: both regions require that you produce a report for all tests. Here are your specs:"}),"\n",(0,t.jsx)(n.p,{children:"Asia Region:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"run tests for Node.js 18 in Ubuntu and Windows"}),"\n",(0,t.jsx)(n.li,{children:"run tests for Node.js 20 in Ubuntu and MacOs"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"Latam Region:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"run tests for Node.js 18 in Ubuntu and Windows"}),"\n",(0,t.jsx)(n.li,{children:"run tests for Node.js 20 in Ubuntu only"}),"\n",(0,t.jsx)(n.li,{children:"run tests for Node.js 22 in Windows, Ubuntu and MacOs"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"Export test report:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Adds a variable to the matrix to indicate if the test report should be exported. Your requirement is that all tests should output a report."}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"For clarity, I'll spell out what jobs will run for each product:"}),"\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"Config"}),(0,t.jsx)(n.th,{children:"Windows"}),(0,t.jsx)(n.th,{children:"Ubuntu"}),(0,t.jsx)(n.th,{children:"MacOs"})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"Region: Asia"}),(0,t.jsx)(n.td,{children:"18"}),(0,t.jsx)(n.td,{children:"18, 20"}),(0,t.jsx)(n.td,{children:"20"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"Region: Latam"}),(0,t.jsx)(n.td,{children:"18, 22"}),(0,t.jsx)(n.td,{children:"18, 20, 22"}),(0,t.jsx)(n.td,{children:"22"})]})]})]}),"\n",(0,t.jsx)(n.h3,{id:"the-declarative-approach",children:"The declarative approach"}),"\n",(0,t.jsx)(n.p,{children:"With this approach, you make each combination very explicit. It's quite easy to see how this can get a bit out of hand as your test suite grows."}),"\n",(0,t.jsxs)(n.p,{children:["But there's a silly trick to make it less awful to read: just tweak the ",(0,t.jsx)(n.code,{children:"include"})," syntax using curly brackets. This is my favourite notation for matrices, as the visual pattern makes the reading more manageable."]}),"\n",(0,t.jsxs)(r,{children:[(0,t.jsx)("summary",{children:(0,t.jsx)(n.p,{children:"Show code"})}),(0,t.jsx)("div",{children:(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-yaml",metastring:'title=".github/workflows/testing.yaml" showLineNumbers',children:'(...)\n  unit-tests:\n    strategy:\n      matrix:\n      include:\n        - {os: windows-latest, node-version: 18, region: Asia, report: true}\n        - {os: windows-latest, node-version: 18, region: Latam, report: true}\n        - {os: windows-latest, node-version: 22, region: Latam, report: true}\n        - {os: ubuntu-latest, node-version: 18, region: Asia, report: true}\n        - {os: ubuntu-latest, node-version: 18, region: Latam, report: true}\n        - {os: ubuntu-latest, node-version: 20, region: Asia, report: true}\n        - {os: ubuntu-latest, node-version: 20, region: Latam, report: true}\n        - {os: ubuntu-latest, node-version: 22, region: Latam, report: true}\n        - {os: macos-latest, node-version: 20, region: Asia, report: true}\n        - {os: macos-latest, node-version: 22, region: Latam, report: true}\n    runs-on: ${{ matrix.os }}\n    steps:\n      - name: Run tests\n        run: | \n          echo "Running tests for Node.js ${{ matrix.node-version }} in ${{ matrix.os }} for product ${{ matrix.product }}"\n          echo "Should report: ${{ matrix.report }}"\n      (...)\n'})})})]}),"\n",(0,t.jsxs)(n.h3,{id:"the-includeexclude-approach",children:["The ",(0,t.jsx)(n.code,{children:"include"}),"/",(0,t.jsx)(n.code,{children:"exclude"})," approach"]}),"\n",(0,t.jsx)(n.p,{children:"Some people might prefer this approach, but it requires a little training to tell what specific jobs will be actually spinned up."}),"\n",(0,t.jsx)(n.p,{children:"In this example, we will build our base matrix with all applicable values:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-yaml",metastring:'title=".github/workflows/testing.yaml"',children:"  matrix:\n    os: [windows-latest, ubuntu-latest, macos-latest]\n    node-version: [18, 20, 22]\n    region: [Asia, Latam]\n"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.em,{children:"As an exercise, how many jobs do we have there?"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"os_length (3) * node-version_length (3) * region_length (2) = 18\n"})}),"\n",(0,t.jsxs)(n.p,{children:["Then we can proceed to trim it down to the desired cases only.",(0,t.jsx)(n.br,{}),"\n","Keep in mind that ",(0,t.jsx)(n.code,{children:"include"})," is processed after ",(0,t.jsx)(n.code,{children:"exclude"}),", so we can use ",(0,t.jsx)(n.code,{children:"include"})," to add back combinations that were previously excluded."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-yaml",children:"  matrix:\n    os: [windows-latest, ubuntu-latest, macos-latest]\n    node-version: [18, 20, 22]\n    region: [Asia, Latam]\n    exclude:\n      - {node-version: 22, region: Asia}                        # Asia has no case for Node.js 22 (-3 jobs)\n      - {node-version: 18, os: macos-latest}                    # MacOs won't test Node.js 18 (-2 jobs)\n      - {node-version: 20, region: Asia, os: windows-latest}    # Windows is the only case without Node.js 20 in Asia (-1 job)\n      - {node-version: 20, region: Latam}                       # There's only one case for Node 20 in Latam, we'll readd it later (-3 jobs)\n    include:\n      - {node-version: 20, region: Latam, os: ubuntu-latest}    # Re-adding the case for Node 20 in Latam (+1 job)\n"})}),"\n",(0,t.jsxs)(r,{children:[(0,t.jsx)("summary",{children:(0,t.jsx)(n.p,{children:"Show pipeline"})}),(0,t.jsx)("div",{children:(0,t.jsx)(n.p,{children:(0,t.jsx)(n.img,{alt:"screenshot",src:i(9287).A+"",width:"650",height:"882"})})})]}),"\n",(0,t.jsxs)(n.p,{children:["And finally, because the report should be added to all cases, we can add ",(0,t.jsx)(n.code,{children:"report"})," under ",(0,t.jsx)(n.code,{children:"include"}),":"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-yaml",children:"  matrix:\n    os: [windows-latest, ubuntu-latest, macos-latest]\n    node-version: [18, 20, 22]\n    region: [Asia, Latam]\n    exclude:\n      - {node-version: 22, region: Asia}\n      - {node-version: 18, os: macos-latest}\n      - {node-version: 20, region: Asia, os: windows-latest}\n      - {node-version: 20, region: Latam}\n    include:\n      - {node-version: 20, region: Latam, os: ubuntu-latest}\n      // highlight-start\n      # doesn't add new jobs, just adds this key to all jobs\n      - report: true \n      // highlight-end\n"})}),"\n",(0,t.jsxs)(r,{children:[(0,t.jsx)("summary",{children:(0,t.jsx)(n.p,{children:"Show pipeline"})}),(0,t.jsx)("div",{children:(0,t.jsx)(n.p,{children:(0,t.jsx)(n.img,{alt:"screenshot",src:i(7892).A+"",width:"1422",height:"912"})})})]}),"\n",(0,t.jsx)(n.p,{children:"And that's how we end with our 10 desired jobs."}),"\n",(0,t.jsx)(n.h2,{id:"simplifying-particular-combinations-in-matrices",children:'Simplifying "particular combinations" in matrices'}),"\n",(0,t.jsxs)(n.p,{children:["If you're using multidimensional matrices, the more configurations you set, the more difficult it is to handle outliers. So here's a trick I learned from ",(0,t.jsx)(n.a,{href:"https://seankilleen.com/2023/08/how-to-specify-pairs-of-items-in-github-actions-matrix-strategies/",children:"Sean Killeen's blog"}),": instead of using ",(0,t.jsx)(n.code,{children:"include"}),", ",(0,t.jsx)(n.code,{children:"exclude"})," and whatnot, you can use maps to easily group key/value pairs that usually go together but don't quite fit a matrix context because they are too tighly coupled. It won't work for all cases, but will be a good solution for plenty of them:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-yaml",metastring:'title=".github/workflows/sean.yaml" showLineNumbers',children:'jobs:\n  build_release:\n    name: "Build and Release"\n    strategy:\n      matrix:\n        // highlight-next-line\n        VERSIONS: [ {ruby: 2.7.3, ghpages: 226}, {ruby: 2.7.4, ghpages: 228}] # tight coupling between rub and ghpages versions, not very "matrixy"\n        NODE_MAJOR_VERSION: [16,18,20]\n    runs-on: ubuntu-latest\n    env:\n      NODE_MAJOR_VERSION: ${{ matrix.NODE_MAJOR_VERSION }}\n      // highlight-start\n      RUBY_VERSION: ${{ matrix.VERSIONS.ruby }}\n      GITHUB_PAGES_VERSION: ${{ matrix.VERSIONS.ghpages }}\n      // highlight-end\n'})}),"\n",(0,t.jsx)(n.p,{children:"--\x3e"}),"\n",(0,t.jsx)(n.h2,{id:"handling-glitches-in-the-matrix",children:"Handling glitches in the matrix"}),"\n",(0,t.jsx)(n.h3,{id:"matrix-job-failures",children:"Matrix job failures"}),"\n",(0,t.jsx)(n.p,{children:"It's true that jobs run in parallel and are independent of each other. But when they are spin up by a matrix, by default, all are cancelled if one of them fails. This is not always desirable, so you can change that behaviour."}),"\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"Option"}),(0,t.jsx)(n.th,{children:"Scope"}),(0,t.jsx)(n.th,{children:"Effects"})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"fail-fast: <boolean>"})}),(0,t.jsx)(n.td,{children:"Entire matrix"}),(0,t.jsxs)(n.td,{children:["Default: ",(0,t.jsx)(n.code,{children:"true"}),". Determines if ",(0,t.jsx)(n.strong,{children:"all"})," ongoing and queued matrix jobs will be cancelled if one job fails"]})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"continue-on-error: <boolean>"})}),(0,t.jsx)(n.td,{children:"Job level"}),(0,t.jsxs)(n.td,{children:["Determines if a failure on a job will bypass ",(0,t.jsx)(n.code,{children:"fail-fast: true"})]})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"matrix.experimental: <boolean>"})}),(0,t.jsx)(n.td,{children:"Job level"}),(0,t.jsxs)(n.td,{children:["Allows jobs to have different ",(0,t.jsx)(n.code,{children:"continue-on-error"})," values"]})]})]})]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-yaml",metastring:'title=".github/workflows/testing.yaml" showLineNumbers',children:"jobs:\n  unit-tests:\n    continue-on-error: false  # default value, can be ommited\n    strategy:\n      // highlight-start\n      fail-fast: true           # default value, can be ommited\n      // highlight-end\n      matrix:\n        node-version: [14, 16, 18]\n      runs-on: ubuntu-latest\n    steps:\n      (...)\n"})}),"\n",(0,t.jsx)(n.h4,{id:"fail-fast",children:(0,t.jsx)(n.code,{children:"fail-fast"})}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"fail-fast"})," is  pretty straightforward. ",(0,t.jsx)(n.code,{children:"true"})," will short-circuit the matrix if one job fails; ",(0,t.jsx)(n.code,{children:"false"})," makes all jobs run independently of each other regardless of job failures."]}),"\n",(0,t.jsx)(n.h4,{id:"continue-on-error",children:(0,t.jsx)(n.code,{children:"continue-on-error"})}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"continue-on-error"})," is a way to add an exclusion to the ",(0,t.jsx)(n.code,{children:"fail-fast"})," setting."]}),"\n",(0,t.jsxs)(n.p,{children:["A matrix with ",(0,t.jsx)(n.code,{children:"fail-fast: true"})," will not fail if ",(0,t.jsx)(n.code,{children:"continue-on-error"})," is ",(0,t.jsx)(n.code,{children:"true"}),". The opposite also stands: a matrix with ",(0,t.jsx)(n.code,{children:"fail-fast: false"})," will fail if ",(0,t.jsx)(n.code,{children:"continue-on-error: false"})," is set."]}),"\n",(0,t.jsxs)(n.p,{children:["Reminder: ",(0,t.jsx)(n.code,{children:"continue-on-error"})," can be used at the step level to prevent a job from failing should that step fail. It can also be used independently of matrices."]}),"\n",(0,t.jsxs)(n.p,{children:["If used alone, ",(0,t.jsx)(n.code,{children:"continue-on-error"})," might at best cancel out ",(0,t.jsx)(n.code,{children:"fail-fast"}),", which is not a big advantage. The real leverage comes when `matrix.experimental is added to the mix."]}),"\n",(0,t.jsx)(n.h4,{id:"matrixexperimental",children:(0,t.jsx)(n.code,{children:"matrix.experimental"})}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"matrix-experimental"})," allows matrix jobs to have different ",(0,t.jsx)(n.code,{children:"continue-on-error"})," values. This way, you can granularly define which failing jobs should or shouldn't halt ongoing & queued jobs."]}),"\n",(0,t.jsxs)(n.p,{children:["An example: you are evaluating a new unstable Node.js version and you want to observe it for a while before release. You don't want the whole matrix to fail if your little experiment fails the tests; it should only fail if stable versions raise issues.",(0,t.jsx)(n.br,{}),"\n","To exclude that one job, you can ",(0,t.jsx)(n.code,{children:"include"})," the new version to the matrix and setting that job as the only one with an experimental value of ",(0,t.jsx)(n.code,{children:"true"}),":"]}),"\n",(0,t.jsxs)(r,{children:[(0,t.jsx)("summary",{children:(0,t.jsx)(n.p,{children:"Show code"})}),(0,t.jsxs)("div",{children:[(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-yaml",metastring:'title=".github/workflows/testing.yaml" showLineNumbers',children:"jobs:\n  unit-tests:\n    strategy:\n      runs-on: ubuntu-latest\n      // highlight-start\n      # ommited fail-fast as it's true by default\n      continue-on-error: ${{ matrix.experimental }} # dynamically set for each job\n      matrix:\n        node-version: [18, 20]\n        experimental: [false] # will populate continue-on-error with false\n        include:\n          - node-version: 21\n            experimental: true # will populate continue-on-error with true, but only for the job running Node v21.\n      // highlight-end\n    steps:\n      (...)\n"})}),(0,t.jsx)(n.p,{children:"So the resulting jobs from this matrix will be:"}),(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"node 18, continue-on-error: false"}),"\n",(0,t.jsx)(n.li,{children:"node 20, continue-on-error: false"}),"\n",(0,t.jsx)(n.li,{children:"node 21, continue-on-error: true"}),"\n"]})]})]}),"\n",(0,t.jsx)(n.h3,{id:"dynamically-generated-matrices-handling-empty-matrix-error",children:"Dynamically-generated matrices: Handling Empty Matrix Error"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.em,{children:"(This section will make more sense once I add the section about dynamically-generated matrices)"}),(0,t.jsx)(n.br,{}),"\n","If you are using dynamically generated matrices, your workflow may fail if the matrix ends up spinning an empty result:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"Error when evaluating 'strategy' for job 'xxxxx'. .github/workflows/my_worflow.yaml (Line: X, Col: Y): Matrix must define at least one vector\n\n"})}),"\n",(0,t.jsx)(n.p,{children:"The fix is to execute the dependent job with a conditional:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-yaml",children:"apply:\n  name: '${{ matrix.account }}'\n  needs: generate\n  // highlight-next-line\n  if: ${{ fromJson(needs.generate.outputs.matrix).include[0] }}\n  strategy:\n    fail-fast: false\n    matrix:\n      include: ${{ fromJSON(needs.generate.outputs.matrix) }}\n"})}),"\n",(0,t.jsx)(n.p,{children:"What is happening here?"}),"\n",(0,t.jsxs)(n.p,{children:["The conditional converts the JSON string to an object, and checks if the ",(0,t.jsx)(n.code,{children:"include"})," key has at least one map. Use fearlessly, because matrices contain the ",(0,t.jsx)(n.code,{children:"includes"})," property whenever a  matrix has any elements - it doesn't depend on using he ",(0,t.jsx)(n.code,{children:"include"})," keyword explicitly on the matrix definition."]}),"\n",(0,t.jsx)(n.p,{children:"##\xa0WIP Sections"}),"\n",(0,t.jsx)(n.p,{children:"Come back later! I've started drafting content for the following sections:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Limitations (e.g. Matrix outputs don't work neatly, they require artifacts)"}),"\n",(0,t.jsx)(n.li,{children:"Dynamically-generated Matrices"}),"\n",(0,t.jsx)(n.li,{children:"Resource Management: Max Number of Concurrent Jobs"}),"\n",(0,t.jsx)(n.li,{children:"Advanced use of matrices with reusable workflows"}),"\n",(0,t.jsx)(n.li,{children:"Sharing a matrix between jobs"}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(c,{...e})}):c(e)}},3356:(e,n,i)=>{i.d(n,{A:()=>t});const t=i.p+"assets/images/screenshot_1-2416938c95afe7c3eb25bb223ae6e44a.png"},6557:(e,n,i)=>{i.d(n,{A:()=>t});const t=i.p+"assets/images/screenshot_13-dbe2b35893fc8c71efef371454d33c33.png"},1698:(e,n,i)=>{i.d(n,{A:()=>t});const t=i.p+"assets/images/screenshot_14-607ec4e34cabe7d266a6c6cd502f4a66.png"},6523:(e,n,i)=>{i.d(n,{A:()=>t});const t=i.p+"assets/images/screenshot_15-66b240a0cec4ffc486515515d4162e6c.png"},4544:(e,n,i)=>{i.d(n,{A:()=>t});const t=i.p+"assets/images/screenshot_16-c76460ae942b5475c4372982d2e2be05.png"},2665:(e,n,i)=>{i.d(n,{A:()=>t});const t=i.p+"assets/images/screenshot_17-2b6284109a2f9ee70a935d6a26ae7568.png"},6798:(e,n,i)=>{i.d(n,{A:()=>t});const t=i.p+"assets/images/screenshot_18-798ba88950c2dd2e411caa5a9e8bf9ba.png"},9287:(e,n,i)=>{i.d(n,{A:()=>t});const t=i.p+"assets/images/screenshot_19-a693471453e522da0174cc92dc9996b1.png"},3415:(e,n,i)=>{i.d(n,{A:()=>t});const t=i.p+"assets/images/screenshot_2-92f6c249ef0af083a25cb8d73c07629d.png"},7892:(e,n,i)=>{i.d(n,{A:()=>t});const t=i.p+"assets/images/screenshot_20-d9a696031344015a590f1f1954f54299.png"},8453:(e,n,i)=>{i.d(n,{R:()=>a,x:()=>o});var t=i(6540);const s={},r=t.createContext(s);function a(e){const n=t.useContext(r);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:a(e.components),t.createElement(r.Provider,{value:n},e.children)}}}]);